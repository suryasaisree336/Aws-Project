<<<<<<< HEAD
# steno [![](http://img.shields.io/npm/dm/steno.svg?style=flat)](https://www.npmjs.org/package/steno)  [![](https://travis-ci.org/typicode/steno.svg?branch=master)](https://travis-ci.org/typicode/steno)

> Simple file writer with __atomic writing__ and __race condition prevention__.

Can be used as a drop-in replacement to `fs.writeFile()`.

Built on [graceful-fs](https://github.com/isaacs/node-graceful-fs) and used in [lowdb](https://github.com/typicode/lowdb).

## Install

```
npm install steno --save
```
=======
# Steno [![](http://img.shields.io/npm/dm/steno.svg?style=flat)](https://www.npmjs.org/package/steno) [![Node.js CI](https://github.com/typicode/steno/actions/workflows/node.js.yml/badge.svg)](https://github.com/typicode/steno/actions/workflows/node.js.yml)

> Specialized fast async file writer

**Steno** makes writing to the same file often/concurrently fast and safe.

Used in [lowdb](https://github.com/typicode/lowdb).

_https://en.wikipedia.org/wiki/Stenotype_

## Features

- Fast (see benchmark)
- Lightweight (~6kb)
- Promise-based
- Atomic write
- No race condition
- TypeScript definitions
>>>>>>> 5d41587588fb608497acbb3a2238024ffd494efb

## Usage

```javascript
<<<<<<< HEAD
const steno = require('steno')

steno.writeFile('file.json', data, err => {
  if (err) throw err
})
```

## The problem it solves

### Without steno

Let's say you have a server and want to save data to disk:

```javascript
var data = { counter: 0 }

server.post('/', (req, res) => {
  // Increment counter
  ++data.counter

  // Save data asynchronously
  fs.writeFile('data.json', JSON.stringify(data), err => {
    if (err) throw err
    res.end()
  })
})
```

Now if you have many requests, for example `1000`, there's a risk that you end up with:

```javascript
// In your server
data.counter === 1000

// In data.json
data.counter === 865 // ... or any other value
```

Why? Because, `fs.write` doesn't guarantee that the call order will be kept. Also, if the server is killed while `data.json` is being written, the file can get corrupted.

### With steno

```javascript
server.post('/increment', (req, res) => {
  ++data.counter

  steno.writeFile('data.json', JSON.stringify(data), err => {
    if (err) throw err
    res.end()
  })
})
```

With steno you'll always have the same data in your server and file. And in case of a crash, file integrity will be preserved.

if needed, you can also use `steno.writeFileSync()` which offers atomic writing too.

__Important: works only in a single instance of Node.__

=======
import { Writer } from 'steno'

// Create a singleton writer
const file = new Writer('file.txt')

// Use it in the rest of your code
async function save() {
  await file.write('some data')
}
```

## Benchmark

`npm run benchmark` (see `src/benchmark.ts`)

```
Write 1KB data to the same file x 1000

  fs     : 62.303ms
  steno  : 1.384ms

  fs.txt = steno.txt ✓


Write 1MB data to the same file x 1000

  fs     : 2.300s
  steno  : 5.444ms

  fs.txt = steno.txt ✓
```

>>>>>>> 5d41587588fb608497acbb3a2238024ffd494efb
## License

MIT - [Typicode](https://github.com/typicode)
